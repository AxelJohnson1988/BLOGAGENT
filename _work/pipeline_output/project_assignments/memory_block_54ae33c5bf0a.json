{
  "id_hash": "54ae33c5bf0a",
  "summary": "#!/usr/bin/env python3\n\"\"\"\nProject Assignment System for MUSE Pantheon\nAuto-assigns project IDs based on content analysis and archetype mapping\n\"\"\"\nimport sys\nimport argparse\nimport json\nimport loggin...",
  "content": "#!/usr/bin/env python3\n\"\"\"\nProject Assignment System for MUSE Pantheon\nAuto-assigns project IDs based on content analysis and archetype mapping\n\"\"\"\nimport sys\nimport argparse\nimport json\nimport logging\nfrom pathlib import Path\nfrom typing import List, Dict, Any, Optional\nfrom collections import defaultdict\nimport re\n\n# Add common directory to path for imports\nsys.path.append(str(Path(__file__).parent.parent.parent / \"common\"))\nfrom memory_block import MemoryBlock\n\n# Setup logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n\nclass ProjectClassifier:\n    \"\"\"Classifies MemoryBlocks into projects based on content and patterns.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the project classifier.\"\"\"\n        self.project_patterns = {\n            'muse.pantheon': {\n                'keywords': ['memory', 'block', 'muse', 'pantheon', 'archetype', 'guardian', 'oracle', 'sage'],\n                'file_patterns': ['memory_block', 'warden', 'pantheon'],\n                'archetypes': ['Guardian', 'Oracle', 'Sage', 'Shaman']\n            },\n            'blog.agent': {\n                'keywords': ['blog', 'post', 'article', 'content', 'writing', 'publish'],\n                'file_patterns': ['blog', 'post', 'article', 'content'],\n                'archetypes': ['Scribe', 'Storyteller', 'Weaver']\n            },\n            'warden.system': {\n                'keywords': ['warden', 'security', 'monitor', 'guardian', 'protection', 'ethics'],\n                'file_patterns': ['warden', 'security', 'monitor'],\n                'archetypes': ['Guardian', 'Warden', 'Protector']\n            },\n            'ai.assistant': {\n                'keywords': ['assistant', 'ai', 'artificial', 'intelligence', 'agent', 'copilot'],\n                'file_patterns': ['assistant', 'ai', 'agent', 'copilot'],\n                'archetypes': ['Oracle', 'Sage', 'Navigator']\n            },\n            'legal.documentation': {\n                'keywords': ['legal', 'contract', 'agreement', 'terms', 'policy', 'compliance'],\n                'file_patterns': ['legal', 'contract', 'terms', 'policy'],\n                'archetypes': ['Guardian', 'Scribe', 'Sage']\n            },\n            'data.analytics': {\n                'keywords': ['data', 'analytics', 'analysis', 'statistics', 'metrics', 'report'],\n                'file_patterns': ['data', 'analytics', 'report', 'stats'],\n                'archetypes': ['Oracle', 'Alchemist', 'Sage']\n            },\n            'creative.content': {\n                'keywords': ['creative', 'design', 'art', 'visual', 'image', 'media'],\n                'file_patterns': ['creative', 'design', 'art', 'media'],\n                'archetypes': ['Visionary', 'Architect', 'Storyteller']\n            },\n            'development.tools': {\n                'keywords': ['development', 'tools', 'utility', 'script', 'automation'],\n                'file_patterns': ['tools', 'utils', 'scripts', 'dev'],\n                'archetypes': ['Alchemist', 'Architect', 'Navigator']\n            }\n        }\n        \n        self.archetype_project_mapping = {\n            'Guardian': ['muse.pantheon', 'warden.system', 'legal.documentation'],\n            'Oracle': ['ai.assistant', 'data.analytics', 'muse.pantheon'],\n            'Sage': ['ai.assistant', 'legal.documentation', 'data.analytics'],\n            'Scribe': ['blog.agent', 'legal.documentation', 'creative.content'],\n            'Storyteller': ['blog.agent', 'creative.content', 'muse.pantheon'],\n            'Visionary': ['creative.content', 'muse.pantheon', 'development.tools'],\n            'Alchemist': ['development.tools', 'data.analytics', 'muse.pantheon'],\n            'Architect': ['development.tools', 'creative.content', 'muse.pantheon'],\n            'Weaver': ['blog.agent', 'creative.content', 'development.tools'],\n            'Navigator': ['ai.assistant', 'development.tools', 'muse.pantheon'],\n            'Shaman': ['muse.pantheon', 'warden.system', 'creative.content'],\n            'Discoverer': ['muse.pantheon', 'data.analytics', 'development.tools']\n        }\n    \n    def classify_memory_block(self, memory_block: MemoryBlock) -> str:\n        \"\"\"Classify a memory block into a project.\"\"\"\n        scores = defaultdict(float)\n        \n        # Score based on content keywords\n        content_text = f\"{memory_block.summary} {memory_block.content} {' '.join(memory_block.topics)}\".lower()\n        \n        for project, patterns in self.project_patterns.items():\n            # Keyword matching\n            for keyword in patterns['keywords']:\n                if keyword in content_text:\n                    scores[project] += 2.0\n            \n            # File pattern matching\n            if memory_block.source_path:\n                source_path = memory_block.source_path.lower()\n                for pattern in patterns['file_patterns']:\n                    if pattern in source_path:\n                        scores[project] += 3.0\n            \n            # Archetype alignment\n            if memory_block.archetype in patterns['archetypes']:\n                scores[project] += 1.5\n        \n        # Additional scoring based on archetype-project mapping\n        if memory_block.archetype in self.archetype_project_mapping:\n            for project in self.archetype_project_mapping[memory_block.archetype]:\n                scores[project] += 1.0\n        \n        # Return highest scoring project or default\n        if scores:\n            return max(scores.items(), key=lambda x: x[1])[0]\n        else:\n            return 'general.development'\n    \n    def get_project_hierarchy(self, project_id: str) -> Dict[str, str]:\n        \"\"\"Get project hierarchy information.\"\"\"\n        hierarchy_map = {\n            'muse.pantheon': {\n                'domain': 'muse',\n                'category': 'pantheon',\n                'subcategory': 'core',\n                'description': 'Core MUSE Pantheon memory system'\n            },\n            'blog.agent': {\n                'domain': 'blog',\n                'category': 'agent',\n                'subcategory': 'content',\n                'description': 'Blog content generation and management'\n            },\n            'warden.system': {\n                'domain': 'warden',\n                'category': 'system',\n                'subcategory': 'security',\n                'description': 'Security and monitoring system'\n            },\n            'ai.assistant': {\n                'domain': 'ai',\n                'category': 'assistant',\n                'subcategory': 'interaction',\n                'description': 'AI assistant and agent systems'\n            },\n            'legal.documentation': {\n                'domain': 'legal',\n                'category': 'documentation',\n                'subcategory': 'compliance',\n                'description': 'Legal documents and compliance'\n            },\n            'data.analytics': {\n                'domain': 'data',\n                'category': 'analytics',\n                'subcategory': 'insights',\n                'description': 'Data analysis and insights'\n            },\n            'creative.content': {\n                'domain': 'creative',\n                'category': 'content',\n                'subcategory': 'media',\n                'description': 'Creative and media content'\n            },\n            'development.tools': {\n                'domain': 'development',\n                'category': 'tools',\n                'subcategory': 'utilities',\n                'description': 'Development tools and utilities'\n            },\n            'general.development': {\n                'domain': 'general',\n                'category': 'development',\n                'subcategory': 'misc',\n                'description': 'General development and miscellaneous'\n            }\n        }\n        \n        return hierarchy_map.get(project_id, {\n            'domain': 'unknown',\n            'category': 'unknown',\n            'subcategory': 'unknown',\n            'description': 'Unknown project category'\n        })\n\n\nclass ProjectAssignmentEngine:\n    \"\"\"Main engine for project assignment.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the assignment engine.\"\"\"\n        self.classifier = ProjectClassifier()\n        self.assignment_stats = defaultdict(int)\n    \n    def assign_projects(self, memory_blocks: List[MemoryBlock]) -> List[MemoryBlock]:\n        \"\"\"Assign projects to all memory blocks.\"\"\"\n        logger.info(f\"Assigning projects to {len(memory_blocks)} memory blocks\")\n        \n        updated_blocks = []\n        \n        for block in memory_blocks:\n            # Classify the block\n            new_project = self.classifier.classify_memory_block(block)\n            \n            # Update project if different\n            if block.project != new_project:\n                logger.debug(f\"Updated project for {block.id_hash}: {block.project} -> {new_project}\")\n                block.project = new_project\n                block.metadata['project_assigned_by'] = 'auto_classifier'\n                block.metadata['original_project'] = block.project if hasattr(block, 'project') else 'unknown'\n            \n            # Add project hierarchy information\n            hierarchy = self.classifier.get_project_hierarchy(new_project)\n            block.metadata['project_hierarchy'] = hierarchy\n            \n            self.assignment_stats[new_project] += 1\n            updated_blocks.append(block)\n        \n        self._log_assignment_stats()\n        return updated_blocks\n    \n    def assign_projects_with_clusters(self, memory_blocks: List[MemoryBlock], \n                                    cluster_labels: List[int]) -> List[MemoryBlock]:\n        \"\"\"Assign projects considering cluster information.\"\"\"\n        logger.info(\"Assigning projects with cluster context\")\n        \n        # First, do standard assignment\n        updated_blocks = self.assign_projects(memory_blocks)\n        \n        # Then, refine based on cluster patterns\n        cluster_project_patterns = self._analyze_cluster_patterns(updated_blocks, cluster_labels)\n        \n        # Apply cluster-based refinements\n        for i, (block, cluster_label) in enumerate(zip(updated_blocks, cluster_labels)):\n            if cluster_label in cluster_project_patterns:\n                cluster_info = cluster_project_patterns[cluster_label]\n                \n                # If cluster has a dominant project, consider switching\n                dominant_project = cluster_info['dominant_project']\n                if (cluster_info['confidence'] > 0.7 and \n                    block.project != dominant_project):\n                    \n                    logger.debug(f\"Cluster-based refinement for {block.id_hash}: {block.project} -> {dominant_project}\")\n                    block.project = dominant_project\n                    block.metadata['project_refined_by_cluster'] = True\n                    block.metadata['cluster_id'] = cluster_label\n        \n        return updated_blocks\n    \n    def _analyze_cluster_patterns(self, memory_blocks: List[MemoryBlock], \n                                cluster_labels: List[int]) -> Dict[int, Dict[str, Any]]:\n        \"\"\"Analyze project patterns within clusters.\"\"\"\n        cluster_projects = defaultdict(lambda: defaultdict(int))\n        cluster_sizes = defaultdict(int)\n        \n        # Count projects per cluster\n        for block, cluster_label in zip(memory_blocks, cluster_labels):\n            cluster_projects[cluster_label][block.project] += 1\n            cluster_sizes[cluster_label] += 1\n        \n        # Analyze patterns\n        patterns = {}\n        for cluster_id, project_counts in cluster_projects.items():\n            total_blocks = cluster_sizes[cluster_id]\n            dominant_project = max(project_counts.items(), key=lambda x: x[1])\n            confidence = dominant_project[1] / total_blocks\n            \n            patterns[cluster_id] = {\n                'dominant_project': dominant_project[0],\n                'confidence': confidence,\n                'total_blocks': total_blocks,\n                'project_distribution': dict(project_counts)\n            }\n        \n        return patterns\n    \n    def _log_assignment_stats(self):\n        \"\"\"Log assignment statistics.\"\"\"\n        logger.info(\"Project assignment statistics:\")\n        for project, count in sorted(self.assignment_stats.items()):\n            logger.info(f\"  {project}: {count} blocks\")\n\n\nclass ProjectReportGenerator:\n    \"\"\"Generates comprehensive project assignment reports.\"\"\"\n    \n    def generate_report(self, memory_blocks: List[MemoryBlock], \n                       output_dir: Path) -> Dict[str, Any]:\n        \"\"\"Generate comprehensive project assignment report.\"\"\"\n        # Analyze project distribution\n        project_stats = defaultdict(lambda: {\n            'count': 0,\n            'archetypes': defaultdict(int),\n            'file_types': defaultdict(int),\n            'blocks': []\n        })\n        \n        for block in memory_blocks:\n            project = block.project\n            project_stats[project]['count'] += 1\n            project_stats[project]['archetypes'][block.archetype] += 1\n            project_stats[project]['file_types'][block.file_type or 'unknown'] += 1\n            project_stats[project]['blocks'].append({\n                'id_hash': block.id_hash,\n                'summary': block.summary,\n                'archetype': block.archetype,\n                'source_path': block.source_path\n            })\n        \n        # Generate project hierarchy visualization\n        hierarchy_data = self._generate_hierarchy_data(project_stats)\n        \n        # Create detailed report\n        report = {\n            'project_assignment_summary': {\n                'total_blocks': len(memory_blocks),\n                'total_projects': len(project_stats),\n                'assignment_timestamp': memory_blocks[0].created_at if memory_blocks else None\n            },\n            'project_statistics': {\n                project: {\n                    'count': stats['count'],\n                    'percentage': (stats['count'] / len(memory_blocks)) * 100,\n                    'top_archetype': max(stats['archetypes'].items(), key=lambda x: x[1])[0] if stats['archetypes'] else 'unknown',\n                    'top_file_type': max(stats['file_types'].items(), key=lambda x: x[1])[0] if stats['file_types'] else 'unknown',\n                    'archetype_distribution': dict(stats['archetypes']),\n                    'file_type_distribution': dict(stats['file_types'])\n                }\n                for project, stats in project_stats.items()\n            },\n            'project_hierarchy': hierarchy_data,\n            'detailed_assignments': {\n                project: stats['blocks'][:10]  # First 10 blocks per project\n                for project, stats in project_stats.items()\n            }\n        }\n        \n        # Save report\n        report_file = output_dir / \"project_assignment_report.json\"\n        with open(report_file, 'w') as f:\n            json.dump(report, f, indent=2)\n        \n        # Generate human-readable summary\n        self._generate_human_readable_summary(report, output_dir)\n        \n        logger.info(f\"Project assignment report saved to: {report_file}\")\n        return report\n    \n    def _generate_hierarchy_data(self, project_stats: Dict[str, Dict]) -> Dict[str, Any]:\n        \"\"\"Generate project hierarchy visualization data.\"\"\"\n        classifier = ProjectClassifier()\n        hierarchy = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))\n        \n        for project in project_stats.keys():\n            hierarchy_info = classifier.get_project_hierarchy(project)\n            domain = hierarchy_info['domain']\n            category = hierarchy_info['category']\n            subcategory = hierarchy_info['subcategory']\n            \n            hierarchy[domain][category][subcategory].append({\n                'project_id': project,\n                'count': project_stats[project]['count'],\n                'description': hierarchy_info['description']\n            })\n        \n        return dict(hierarchy)\n    \n    def _generate_human_readable_summary(self, report: Dict[str, Any], output_dir: Path):\n        \"\"\"Generate human-readable project summary.\"\"\"\n        summary_lines = []\n        summary_lines.append(\"MUSE Pantheon Project Assignment Summary\")\n        summary_lines.append(\"=\" * 50)\n        summary_lines.append(\"\")\n        \n        # Overall stats\n        total_blocks = report['project_assignment_summary']['total_blocks']\n        total_projects = report['project_assignment_summary']['total_projects']\n        \n        summary_lines.append(f\"Total Memory Blocks: {total_blocks}\")\n        summary_lines.append(f\"Total Projects: {total_projects}\")\n        summary_lines.append(\"\")\n        \n        # Project breakdown\n        summary_lines.append(\"Project Distribution:\")\n        summary_lines.append(\"-\" * 20)\n        \n        for project, stats in sorted(report['project_statistics'].items(), \n                                   key=lambda x: x[1]['count'], reverse=True):\n            percentage = stats['percentage']\n            count = stats['count']\n            archetype = stats['top_archetype']\n            \n            summary_lines.append(f\"  {project}: {count} blocks ({percentage:.1f}%) - Primary archetype: {archetype}\")\n        \n        summary_lines.append(\"\")\n        summary_lines.append(\"Project Hierarchy:\")\n        summary_lines.append(\"-\" * 15)\n        \n        # Hierarchy breakdown\n        for domain, categories in report['project_hierarchy'].items():\n            summary_lines.append(f\"  Domain: {domain}\")\n            for category, subcategories in categories.items():\n                summary_lines.append(f\"    Category: {category}\")\n                for subcategory, projects in subcategories.items():\n                    for project_info in projects:\n                        summary_lines.append(f\"      - {project_info['project_id']} ({project_info['count']} blocks)\")\n        \n        # Save summary\n        summary_file = output_dir / \"project_assignment_summary.txt\"\n        with open(summary_file, 'w') as f:\n            f.write('\\n'.join(summary_lines))\n        \n        logger.info(f\"Human-readable summary saved to: {summary_file}\")\n\n\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Project Assignment for MUSE Pantheon\")\n    parser.add_argument('--blocks-dir', required=True,\n                       help='Directory containing MemoryBlock JSON files')\n    parser.add_argument('--output-dir', required=True,\n                       help='Output directory for project assignments')\n    parser.add_argument('--clusters-file', \n                       help='Optional clusters file for cluster-aware assignment')\n    \n    args = parser.parse_args()\n    \n    blocks_dir = Path(args.blocks_dir)\n    output_dir = Path(args.output_dir)\n    output_dir.mkdir(parents=True, exist_ok=True)\n    \n    # Load memory blocks\n    logger.info(f\"Loading memory blocks from: {blocks_dir}\")\n    memory_blocks = []\n    \n    for json_file in blocks_dir.glob(\"*.json\"):\n        # Skip non-memory block files\n        if not json_file.name.startswith(\"memory_block_\"):\n            continue\n            \n        try:\n            with open(json_file, 'r') as f:\n                data = json.load(f)\n                block = MemoryBlock.from_dict(data)\n                memory_blocks.append(block)\n        except Exception as e:\n            logger.error(f\"Failed to load {json_file}: {str(e)}\")\n    \n    if not memory_blocks:\n        logger.error(\"No memory blocks found!\")\n        return 1\n    \n    logger.info(f\"Loaded {len(memory_blocks)} memory blocks\")\n    \n    # Load clusters if provided\n    cluster_labels = None\n    if args.clusters_file:\n        try:\n            with open(args.clusters_file, 'r') as f:\n                cluster_data = json.load(f)\n                cluster_labels = cluster_data.get('clustering_results', {}).get('cluster_labels', [])\n                logger.info(f\"Loaded cluster labels for {len(cluster_labels)} blocks\")\n        except Exception as e:\n            logger.warning(f\"Failed to load clusters file: {str(e)}\")\n    \n    # Assign projects\n    assignment_engine = ProjectAssignmentEngine()\n    \n    if cluster_labels and len(cluster_labels) == len(memory_blocks):\n        updated_blocks = assignment_engine.assign_projects_with_clusters(memory_blocks, cluster_labels)\n    else:\n        updated_blocks = assignment_engine.assign_projects(memory_blocks)\n    \n    # Save updated memory blocks\n    logger.info(\"Saving updated memory blocks...\")\n    for block in updated_blocks:\n        block.save(output_dir)\n    \n    # Generate comprehensive report\n    report_generator = ProjectReportGenerator()\n    report = report_generator.generate_report(updated_blocks, output_dir)\n    \n    logger.info(f\"Project assignment complete. Updated {len(updated_blocks)} blocks.\")\n    \n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())",
  "topics": [
    "assign",
    "blocks",
    "return",
    "py",
    "memory",
    "projects",
    "assignment",
    "project"
  ],
  "skills": [
    "nano_warden_universal_ingest_py.py",
    "nano_warden_code_analyzer.py",
    "nano_warden_dependency_tracker.py",
    "nano_warden_memory_system.py"
  ],
  "date": "2025-09-17",
  "project": "muse.pantheon",
  "archetype": "Alchemist",
  "created_at": "2025-09-17T18:19:13.041646+00:00",
  "source_path": "warden/tools/assign_projects.py",
  "file_type": ".py",
  "pii_redacted": false,
  "consent_logged": true,
  "ethics_review": "passed",
  "links": [],
  "parent_blocks": [],
  "metadata": {
    "file_size": 21074,
    "source": "file_ingest",
    "validation_status": "passed",
    "project_assigned_by": "auto_classifier",
    "original_project": "muse.pantheon",
    "project_hierarchy": {
      "domain": "muse",
      "category": "pantheon",
      "subcategory": "core",
      "description": "Core MUSE Pantheon memory system"
    }
  }
}